import itertools
import os
import collections
from snakemake.utils import R
from snakemake.exceptions import MissingInputException

shell.prefix("set -eo pipefail; ")
TEMP="/lscratch/${{SLURM_JOBID}}"
configfile: "/data/khanlab/projects/patidar/Snakemake/config_common.json"
configfile: "/data/khanlab/projects/patidar/Snakemake/config_cluster.json"

localrules: Khanlab_Pipeline
####
#### Targets
####
ALL_SAMPLES = config["samples"]
ALL_FASTQC  = expand("{sample}/fastqc/{sample}_R2_fastqc.html", sample = ALL_SAMPLES)
ALL_QC   = expand("{sample}/{sample}.flagstat.txt", sample = ALL_SAMPLES) + expand("{sample}/{sample}.hotspot.depth", sample = ALL_SAMPLES) + expand("{sample}/{sample}.gt", sample = ALL_SAMPLES) + expand("{sample}/BamQC/qualimapReport.html", sample = ALL_SAMPLES)


ALL_GERMLINE= expand("{sample}/{sample}.hapcaller.snpEff.vcf", sample = ALL_SAMPLES) + expand("{sample}/{sample}.platypus.snpEff.vcf", sample = ALL_SAMPLES) + expand("{sample}/{sample}.freebayes.snpEff.vcf", sample = ALL_SAMPLES)
ALL_SOMATIC = []
somaticPairs = {}
pairedCapture = {}
if len(config['sample_references']) > 0:
	for Tumor in config['sample_references']:
		for Normal in config['sample_references'][Tumor]:
			TumorBam = "{sample}/{sample}.final".format(sample=Tumor)
			NormalBam = "{sample}/{sample}.final".format(sample=Normal)
			pairedCapture[Tumor] = config['sample_captures'][Tumor]
			somaticPairs[Tumor] = [TumorBam + ".bam" , TumorBam + ".bai", NormalBam + ".bam", NormalBam + ".bai"]
			ALL_SOMATIC += ["{sample}/{sample}.MuTect.snpEff.vcf".format(sample=Tumor)]
			ALL_SOMATIC += ["{sample}/{sample}.strelka.snvs.snpEff.vcf".format(sample=Tumor)]
			ALL_SOMATIC += ["{sample}/{sample}.strelka.indels.snpEff.vcf".format(sample=Tumor)]

###########################################################################
###########################################################################
rule Khanlab_Pipeline:
	input: ALL_QC, ALL_FASTQC, ALL_GERMLINE, ALL_SOMATIC
#ALL_FASTQC, ALL_SOMATIC, ALL_GERMLINE
############
#	FASTQC
############
rule fastqc:
	input:
		R1="{sample}/{sample}_R1.fastq.gz",
		R2="{sample}/{sample}_R2.fastq.gz"
	output: 
		"{sample}/fastqc/{sample}_R1_fastqc.zip", 
		"{sample}/fastqc/{sample}_R2_fastqc.zip", 
		"{sample}/fastqc/{sample}_R1_fastqc.html", 
		"{sample}/fastqc/{sample}_R2_fastqc.html"
	log: "{sample}/pbs_log/fastqc"
	version: config["fastqc"]
	threads: 10
	message: "Running Fastqc on {input[0]}"
	params:
		rulename  = "fastqc",
		batch     = config["job_fastqc"]
	shell: """
	#######################
	module load fastqc/{version}
	fastqc -t {threads} -o {wildcards.sample}/fastqc/ -d /scratch {input[R1]} 2>> {log}
	fastqc -t {threads} -o {wildcards.sample}/fastqc/ -d /scratch {input[R2]} 2>> {log}
	#######################
	"""
############
#       BWA
############
rule BWA:
	input: 
		R1="{sample}/{sample}_R1.fastq.gz", 
		R2="{sample}/{sample}_R2.fastq.gz",
		ref=config["bwaIndex"]
	output: 
		"{sample}/{sample}.bam", 
		"{sample}/{sample}.bam.bai"
	log: "{sample}/pbs_log/bwa"
	version: config["bwa"]
	threads: 32
	message: "Running bwa on {input[0]}"
	params:
		rulename  = "bwa",
		platform  = config["platform"],
		samtools  = config["samtools"], 
		batch     = config["job_bwa"]
	shell: """
	#######################
	module load bwa/{version}
	module load samtools/{params.samtools}
	bwa mem -M  -t {threads} -R \"@RG\\tID:{wildcards.sample}\\tSM:{wildcards.sample}\\tLB:{wildcards.sample}\\tPL:{params.platform}\" {input[ref]} {input[R1]} {input[R2]} 2> {log}| samtools view -Sbh - |samtools sort -m 30000000000 - {wildcards.sample}/{wildcards.sample}
	samtools index {wildcards.sample}/{wildcards.sample}.bam
	#######################
	"""
############
#       GenotypeFile
############
# Using Older version of samtools for this purpose
rule Genotyping:
	input:
		bam="{sample}/{sample}.final.bam",
		interval=config["genotypeBed"],
		ref=config["reference"],
		vcf2genotype=config["vcf2genotype"]
	output:
		vcf="{sample}/{sample}.samtools.vcf",
		gt="{sample}/{sample}.gt"
	log: "{sample}/pbs_log/genotyping"
	version: config["samtools_old"]
	threads: 2
	message: "Making Genotyping Input file on {input[0]}"
	params:
		rulename  = "genotype",
		batch     = config["job_genotype"],
		dest	  = config["genotypeDest"]
	shell: """
	#######################
	module load samtools/{version}
	samtools mpileup -u -C50 -f {input.ref} -l {input.interval} {input.bam} | bcftools view -gc - >{output.vcf} 2>{log}
	perl {input.vcf2genotype} {output.vcf} >{output.gt} 2>>{log}
	cp -f {output.gt} {params.dest}/{output.gt} 2>>{log}
	#######################
	"""	
############
#       BamQC
############
rule BamQC:
	input:
		bam="{sample}/{sample}.final.bam",
		bai="{sample}/{sample}.final.bai",
		interval= lambda wildcards: config['sample_captures'][wildcards.sample].replace('.bed', '.gff')
	output:
		"{sample}/BamQC/qualimapReport.html"
	log: "{sample}/pbs_log/{sample}.bamqc.log"
	version: config["qualimap"]
	threads: 32
	message: "Running BamQC on {input[0]}"
	params: 
		rulename = "bamqc",
		batch	 = config["job_qualimap"],
		outdir	 ="{sample}/BamQC",
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load qualimap/{version}
	qualimap bamqc -c -bam {input.bam} -outdir {params.outdir} -gff {input.interval} -nt {threads} --java-mem-size=${{MEM}}G > {log} 2>&1
	#######################
	"""
############
#       Samtools flagstat
############
rule flagstat:
	input:	"{sample}/{sample}.bam"
	output: "{sample}/{sample}.flagstat.txt"
	log:    "{sample}/pbs_log/flagstat"
	version: config["samtools"]
	threads: 1
	message: "Running samtools flagstat on {input[0]}"
	params:
		rulename  = "flagstat",
		batch     = config["job_flagstat"]
	shell: """
	#######################
	module load samtools/{version}
	samtools flagstat {input} > {output}
	#######################
	"""
############
#       Hotspot Coverage
############
rule HotSpotCoverage:
	input:	
		bam="{sample}/{sample}.final.bam",
		interval=config["hotspot_intervals"]
	output: "{sample}/{sample}.hotspot.depth"
	log: "{sample}/pbs_log/hotspotCoverage"
	version: config["bedtools"]
	threads: 1
	message: "Running Hotspot Coverage flagstat on {input[0]}"
	params:
		rulename  = "HotSpotCov",
		batch     = config["job_hotspot"],
		samtools  = config["samtools"]
	shell: """
	#######################
	module load samtools/{params.samtools} 
	module load bedtools/{version}
	samtools view -hF 0x400 -q 30 {input.bam} | samtools view -ShF 0x4 - | samtools view -SuF 0x200 - | bedtools coverage -abam - -b {input.interval} >{output}
	
	#######################
	"""

############
#       Picard Mark Duplicates
############
rule Picard_MarkDup:
	input: bam="{sample}/{sample}.bam"
	output: 
		bam="{sample}/{sample}.dd.bam",
		index="{sample}/{sample}.dd.bam.bai",
		metrics="{sample}/{sample}.markdup.txt"
	log:    "{sample}/pbs_log/markdup"
	version: config["picard"]
	threads: 1
	message: "Running picard mark duplicates on {input[0]}"
	params:
		rulename  = "mark_dup",
		batch     = config["job_markdup"],
		samtools  = config["samtools"]    
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load picard/{version}
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar $PICARDJARPATH/MarkDuplicates.jar AS=true M={output.metrics} I={input.bam} O={output.bam} REMOVE_DUPLICATES=false VALIDATION_STRINGENCY=SILENT > {log} 2>&1
	module load samtools/{params.samtools}
	samtools index {output.bam}
	######################
	"""
############
#       GATK Best Practices
############
rule GATK:
	input: 	bam="{sample}/{sample}.dd.bam",
		ref=config["reference"],
		phase1=config["1000G_phase1"],
		mills=config["Mills_and_1000G"]
	output:
		bam="{sample}/{sample}.final.bam",
		index="{sample}/{sample}.final.bai",
	log:    "{sample}/pbs_log/gatk"
	version: config["GATK"]
	threads: 32
	message: "Running GATK Best practices on {input.bam}"
	params:
		rulename  = "gatk",
		batch     = config["job_gatk"]
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load GATK/{version}
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar $GATK_JAR -T RealignerTargetCreator -R {input.ref} -known {input.phase1} -known {input.mills} -I {input.bam} -o /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.realignment.intervals > {log} 2>&1
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar $GATK_JAR -T IndelRealigner -R {input.ref} -known {input.phase1} -known {input.mills} -I {input.bam} --targetIntervals /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.realignment.intervals -o /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.lr.bam >>{log} 2>&1
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar $GATK_JAR -T BaseRecalibrator -R {input.ref} -knownSites {input.phase1} -knownSites {input.mills} -I /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.lr.bam -o /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.recalibration.matrix.txt >>{log} 2>&1
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar $GATK_JAR -T PrintReads -R {input.ref} -I /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.lr.bam -o {output.bam} -BQSR /lscratch/${{SLURM_JOBID}}/{wildcards.sample}.recalibration.matrix.txt >>{log} 2>&1
	######################
	"""
############
#       MuTect
############
rule MuTect:
	input:
		lambda wildcards: somaticPairs[wildcards.Tumor],
		ref=config["reference"],
		dbsnp=config["dbsnp"],
		cosmic=config["cosmic"],
		interval=pairedCapture[Tumor]
	output:
		vcf="{Tumor}/{Tumor}.MuTect.vcf",
		call_stats="{Tumor}/{Tumor}.mutect.call_stats.txt",
		coverage="{Tumor}/{Tumor}.mutect.coverage.wig.txt"
	log:	"{Tumor}/pbs_log/mutect"
	version: config["MuTect"]
	threads: 10
	params:
		rulename  = "MuTect",
		batch     = config["job_mutect"],
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	gawk '{{print $1 "\t" $2-1 "\t" $3}}' {input.interval} > /lscratch/${{SLURM_JOBID}}/target_intervals.bed
	module load muTect/{version}
	java -Xmx${{MEM}}g -jar $MUTECTJARPATH -T MuTect \
		--reference_sequence {input.ref} \
		--cosmic {input.cosmic} \
		--dbsnp {input.dbsnp} \
		--input_file:normal {input[0]} \
		--input_file:tumor {input[2]} \
		--intervals  /lscratch/${{SLURM_JOBID}}/target_intervals.bed \
		--coverage_file {output.coverage} \
		--out {output.call_stats} \
		--vcf {output.vcf} \
		> {log} 2>&1
	#######################
	"""
############
#       Strelka
############
rule Strelka:
	input:
		lambda wildcards: somaticPairs[wildcards.Tumor],
		ref=config["reference"],
		config=config["strelka_config"],
		interval=pairedCapture[Tumor]
	output:
		snps="{Tumor}/{Tumor}.strelka.snvs.vcf",
		indels="{Tumor}/{Tumor}.strelka.indels.vcf"
	log:    "{Tumor}/pbs_log/strelka"
	version: config["strelka"]
	threads: 32
	params:
		rulename = "Strelka",
		batch    = config["job_strelka"],
		vcftools = config["vcftools"]
	shell: """
	#######################
	module load strelka/{version}
	configureStrelkaWorkflow.pl --normal={input[0]} --tumor={input[2]}\
	--ref={input.ref} --config={input.config} --output-dir=/lscratch/${{SLURM_JOBID}}/strelka > {log} 2>&1
	make -j {threads} -f /lscratch/${{SLURM_JOBID}}/strelka/Makefile 2 >> {log}
	module load vcftools/{params.vcftools}
	vcftools --vcf /lscratch/${{SLURM_JOBID}}/strelka/results/all.somatic.snvs.vcf --bed {input.interval} --out {output[0]} --recode --keep-INFO-all
	mv {output[0]}.recode.vcf {output.snps}
	vcftools --vcf /lscratch/${{SLURM_JOBID}}/strelka/results/all.somatic.indels.vcf --bed {input.interval} --out {output[1]} --recode --keep-INFO-all
	mv {output[1]}.recode.vcf {output[1]}
	#######################
	"""
############
#       HaplotypeCaller
############
rule Haplotype_Caller :
	input:
		bam="{sample}/{sample}.final.bam",
		bai="{sample}/{sample}.final.bai",
		ref=config["reference"],
                dbsnp=config["dbsnp"],
		interval= lambda wildcards: config['sample_captures'][wildcards.sample]
	output:
		vcf="{sample}/{sample}.hapcaller.vcf"
	log:    "{sample}/pbs_log/hapcaller"
	version: config["GATK"]
	threads: 5
	params:
		rulename = "HapCall",
		batch    = config["job_gatk"]
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load GATK/{version}
	gawk '{{print $1 "\t" $2-1 "\t" $3}}' {input.interval} > /lscratch/${{SLURM_JOBID}}/target_intervals.bed
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar $GATK_JAR -T HaplotypeCaller -R {input.ref} -I {input.bam} -L /lscratch/${{SLURM_JOBID}}/target_intervals.bed -o {output.vcf} --dbsnp {input.dbsnp} -mbq 20 -mmq 30 -log {log}

	#######################
	"""
############
#       Platypus
############
rule  Platypus:
	input:
		bam="{sample}/{sample}.final.bam",
		bai="{sample}/{sample}.final.bai",
		ref=config["reference"],
		interval= lambda wildcards: config['sample_captures'][wildcards.sample]
	output:
		vcf="{sample}/{sample}.platypus.vcf"
	log:    "{sample}/pbs_log/platypus"
	version: config["platypus"]
	threads: 32
	params:
		rulename = "platypus",
		batch    = config["job_platypus"]
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load platypus/{version}
	platypus callVariants --nCPU={threads} --bufferSize=1000000 --maxReads=100000000 --bamFiles={input.bam} --regions={input.interval} --output={output.vcf} --refFile={input.ref} --logFileName={log} 
	#######################
	"""
############
#       FreeBayes
############
rule  FreeBayes:
	input:
		bam="{sample}/{sample}.final.bam",
		bai="{sample}/{sample}.final.bai",
		ref=config["reference"],
		interval= lambda wildcards: config['sample_captures'][wildcards.sample]
	output:
		vcf="{sample}/{sample}.freebayes.vcf"
	log:    "{sample}/pbs_log/freebayes"
	version: config["freebayes"]
	threads: 32
	params:
		rulename = "freebayes",
		batch    = config["job_freebayes"],
		vcftools = config["vcftools"]
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load freebayes/{version}
	freebayes -f {input.ref} --haplotype-length 50 -b {input.bam} -v {output.vcf} > {log} 2>&1
	
	
	module load vcftools/{params.vcftools}
	vcftools --vcf {output} --bed {input.interval} --out {output.vcf} --recode --keep-INFO-all
	mv {output.vcf}.recode.vcf {output.vcf}
	
	#######################
	"""


############
#	snpEff
############
rule snpEff:
	input:
		vcf="{sample}/{sample}.{base}.vcf",
		ref=config["reference"],
		snpEff_config=config["snpEff_config"],
	output:
		"{sample}/{sample}.{base}.snpEff.vcf"
	log: "{sample}/pbs_log/{base}.snpEff"
	version: config["snpEff"]
	threads: 32
	params:
		rulename   = "snpEff",
		batch	   = config["job_snpeff"],
		snpEff_genome=config["snpEff_genome"]
	shell: """
	#######################
	MEM=`echo "{params.batch}" |perl -n -e'/--mem=(\d+)/ && print \$1'`
	module load snpEff/{version}
	java -Xmx${{MEM}}g -Djava.io.tmpdir=/lscratch/${{SLURM_JOBID}} -jar ${{SNPEFFHOME}}/SnpSift.jar dbnsfp -c {input.snpEff_config} -a {input.vcf} | java -Xmx${{MEM}}g -jar ${{SNPEFFHOME}}/snpEff.jar -t -canon {params.snpEff_genome} > {output} 2> {log}
	#######################
	"""
